# 3.2.0

## Overview ##

### CMS

 * Migration of code to use new parameterised framework

### Framework

 * Implementation of a parameterised query framework eliminating the need to manually escape variables for
   use in SQL queries. This has been integrated into nearly every level of the database ORM.
 * Refactor of database connectivity classes into separate components linked together through dependency injection
 * Refactor of `SQLQuery` into separate objects for each query type: `SQLSelect`, `SQLDelete`, `SQLUpdate` and `SQLInsert`
 * Rename of API methods to conform to coding conventions
 * PDO is now a standard connector, and is available for all database interfaces
 * Additional database and query generation tools

## Bugfixes

 * Reduced database regeneration chances on subsequent rebuilds after the initial dev/build
 * Elimination of various SQL injection vulnerability points
 * `DataObject::writeComponents()` now called correctly during `DataObject::write()`
 * Fixed missing theme declaration in installer
 * Fixed incorrect use of non-existing exception classes (e.g. `HTTPResponse_exception`)
 * `GridState` fixed to distinguish between check for missing values, and creation of
   nested state values, in order to prevent non-empty values being returned for
   missing keys. This was breaking `DataObject::get_by_id` by passing in an object
   for the ID.
 * Fixed order of `File` fulltext searchable fields to use same order as actual fields.
   This is required to prevent unnecessary rebuild of MS SQL databases when fulltext
   searching is enabled.

## Upgrading

### Update code that interacts with SQL strings to use parameters

Previously each of the functions `DataList`, `DataQuery` and `SQLQuery` each had a sql()
function which took no parameters, and returned a single SQL string representing
the query. As a part of the move from raw SQL queries to parameterised queries each of
these sql functions now take a single parameter passed by reference, which is used
to retrieve the list of parameters for any placeholders (denoted with '?') in 
the SQL string.

Because any code may inject parameterised conditions into an existing query all
`SQLQuery` objects are treated as parameterised for consistency.

```php
// Generate query
$query = SQLSelect::create()
	->setFrom('"SiteTree"')
	->setWhere(array('"SiteTree"."Title" LIKE ?' => 'Bananas'));

// Inspect elements of the query
$sql = $query->sql($parameters);
var_dump($sql); // string 'SELECT * FROM "SiteTree" WHERE ("SiteTree"."Title" LIKE ?)' (length=58)
var_dump($parameters); // array 0 => string 'Bananas' (length=7)

// Pass to database connector
DB::prepared_query($sql, $parameters);
```

The point that the sql function is called is also the point at which any `SQLConditionGroup`
instances are evaluated.

Also note that the parameters may not be a single level array, as certain values
may be forced to be cast as a certain type (where supported by the current API).

E.g.

```php
$parameters = array(
	10,
	array('value' => 0, 'type' => 'boolean') // May also contain other database API specific options
)
DB::prepared_query('DELETE FROM "MyObject" WHERE ParentID = ? OR IsValid = ?', $parameters);
```

As a result of this upgrade there are now very few cases where Convert::raw2sql should be used, such
as in complicated nested subqueries which may actually sit in either the SELECT or FROM
fragments of a SELECT query (as parameters generally only pertain to WHERE fragments).


Writing conditions can be done in any of the following ways:

#### SQL Predicates with Parameters

This is the preferred method of declaring conditions on a query. Any predicate can
have any number of parameters (even zero). Each is typically given as
a single-length array, with the key being the SQL condition fragment, and the value being the
parameter (or parameters).

E.g.

```php

// multiple predicates with parameters
$query->addWhere(array('"Column" = ?' => $column, '"Name" = ?' => $value)));

// Shorthand for simple column comparison (as above), omitting the '?'
// These will each be expanded internally to 
$query->addWhere(array('"Column"' => $column, '"Name"' => $value)));

// Multiple predicates, each with multiple parameters.
// Note that the parameters must not be an associative array to distinguish
// it from the subsequent case.
$query->addWhere(array(
	"ColumnOne = ? OR ColumnTwo != ?" => array(1, 4),
	"ID != ?" => $value
));

// Multiple predicates, with explicitly typed parameters
// SQLQuery distinguishes these from predicates with multiple parameters
// by checking for the 'value' key in any array parameter given
$query->addWhere(array(
	'"Column"' => array(
		'value' => $value,
		'type' => 'string' // or any php type
	),
	'"HasValue"' => array(
		'value' => 0,
		'type' => 'boolean'
	)
));
```

#### Run-Time Evaluated Conditions with SQLConditionGroup

Conditional expressions and groups may be encapsulated within a class (implementing
the SQLConditionGroup interface) and evaluated at the time of execution.

This is useful for conditions which may be placed into a query before the details
of that condition are fully specified.

E.g.

```php

class RandomGroup extends SQLConditionGroup {
	public $field = null;
	public function conditionSQL(&$parameters) {
		$parameters = array();
		return "'{$this->field}' < RAND()";
	}
}

$query = SQLSelect::create()
	->setFrom('"MyObject"')
	->setWhere($condition = new RandomCondition());
$condition->field = '"Score"';
$items = $query->execute();
```

#### Direct SQL Predicate

Conditions can be a literal piece of SQL which doesn't involve any parameters or values
at all, or can using safely SQL-encoded values, as it was originally.

For instance, the following are all valid ways of adding SQL conditions directly to a query

```php
// the entire predicate as a single string
$query->addWhere("\"Column\" = 'Value'");

// multiple predicates as an array
$query->addWhere(array("\"Column\" = 'Value'", "\"Column\" != 'Value'"));

// Shorthand for the above using argument expansion
$query->addWhere("\"Column\" = 'Value'", "\"Column\" != 'Value'");

// Literal SQL condition
$query->addWhere('"Created" > NOW()"');
```

### Update code that uses SQLQuery

SQLQuery is still implemented, but now extends the new SQLSelect class and has some methods
deprecated. Previously this class was used for both selecting and querying, but these
have been superceded by the specialised SQLSelect and SQLDelete classes. Additionally,
3.2 now provides SQLUpdate and SQLInsert to generate parameterised query friendly
data updates.

SQLSelect, SQLDelete and SQLUpdate all inherit from SQLConditionalExpression, which
implements toSelect, toDelete, and toUpdate to generate basic transformations
between query types.

In the past SQLQuery->setDelete(true) would be used to turn a select into a delete, 
although now a new SQLDelete object should be created from a separate SQLSelect.

Before:

```php
$query = new SQLQuery('*');
$query->setFrom('"SiteTree"');
$query->setWhere('"SiteTree"."ShowInMenus" = 0');
$query->setDelete(true);
$query->execute();
```

After:

```php
$query = SQLDelete::create()
	->setFrom('"SiteTree"')
	->setWhere(array('"SiteTree"."ShowInMenus"' => 0));
$query->execute();
```

Alternatively:

```php
$query = SQLSelect::create()
	->setFrom('"SiteTree"')
	->setWhere(array('"SiteTree"."ShowInMenus"' => 0))
	->toDelete();
$query->execute();
```

Also, take care for any code or functions which expect an object of type `SQLQuery`, as 
these references should be replaced with `SQLSelect`. Legacy code which generates
`SQLQuery` can still communicate with new code that expects `SQLSelect` as it is a
subclass of `SQLSelect`, but the inverse is not true.

### Using SQLUpdate and SQLDelete

todo

### Update code that interacts with the DB schema

Updating database schema is now done by `updateSchema` with a callback, rather than relying
on user code to call `beginSchemaUpdate` and `endSchemaUpdate` around the call.

Since the schema management object is separate from the database controller you
interact with it via `DB::get_schema` instead of `DB::get_conn` (previously named
`DB::getConn`)

Before:

```php
$conn = DB::getConn();
$conn->beginSchemaUpdate();
foreach($dataClasses as $dataClass) {
	singleton($dataClass)->requireTable();
}
$conn->endSchemaUpdate();
```

After:

```php
$schema = DB::get_schema();
$schema->schemaUpdate(function() use($dataClasses){
	foreach($dataClasses as $dataClass) {
		singleton($dataClass)->requireTable();
	}
});
```

Also should be noted is that many functions have been renamed to conform better with 
coding conventions. E.g. `DB::requireTable` is now `DB::require_table`

### Other

 * PHPDoc has been updated and improved in many places
 * Helper function `DB::placeholders` can be used to generate a comma separated list of placeholders
   useful for creating "WHERE ... IN (?,...)" SQL fragments
 * Implemented Convert::symbol2sql to safely encode database and table names and identifiers.
   E.g. `Convert::symbol2sql('table.column') => '"table"."column"';`
 * `Convert::raw2sql` may now quote the escaped value, as well as safely escape it, according to the current
   database adaptor's preference.
 * `DB` class has been updated and many static methods have been renamed to conform to coding convention.
	* Renamed API:
		- `affectedRows` -> `affected_rows`
		- `checkAndRepairTable` -> `check_and_repair_table`
		- `createDatabase` -> `create_database`
		- `createField` -> `createField`
		- `createTable` -> `createTable`
		- `dontRequireField` -> `dont_require_field`
		- `dontRequireTable` -> `dont_require_table`
		- `fieldList` -> `field_list`
		- `getConn` -> `get_conn`
		- `getGeneratedID` -> `get_generated_id`
		- `isActive` -> `is_active`
		- `requireField` -> `require_field`
		- `requireIndex` -> `require_index`
		- `requireTable` -> `require_table`
		- `setConn` -> `set_conn`
		- `tableList` -> `table_list`
	* Deprecated API:
		- `getConnect` (Was placeholder for PDO connection string building code, but is made
		  redundant after the PDOConnector being fully abstracted)
	* New API:
		- `build_sql` - Hook into new SQL generation code
		- `get_connector` (Nothing to do with getConnect)
		- `get_schema`
		- `placeholders`
		- `prepared_query`
 * `SS_Database` class has been updated and many functions have been deprecated, or refactored into
   the various other database classes. Most of the database management classes remain in the database
   controller, due to individual databases (changing, creating of, etc) varying quite a lot from
   API to API, but schema updates within a database itself is managed by an attached DBSchemaManager
	* Refactored into DBSchemaManager:
		- `createTable`
		- `alterTable`
		- `renameTable`
		- `createField`
		- `renameField`
		- `fieldList`
		- `tableList`
		- `hasTable`
		- `enumValuesForField`
		- `beginSchemaUpdate` and `endSchemaUpdate` -> Use `schemaUpdate` with a callback
		- `cancelSchemaUpdate`
		- `isSchemaUpdating`
		- `doesSchemaNeedUpdating`
		- `transCreateTable`
		- `transAlterTable`
		- `transCreateField`
		- `transCreateField`
		- `transCreateIndex`
		- `transAlterField`
		- `transAlterIndex`
		- `requireTable`
		- `dontRequireTable`
		- `requireIndex`
		- `hasField`
		- `requireField`
		- `dontRequireField`
	* Refactored into DBQueryBuilder
		- `sqlQueryToString`
	* Deprecated:
		- `getConnect` - Was intended for use with PDO, but was never implemented, and is now
		  redundant, now that there is a stand-alone `PDOConnector`
		- `prepStringForDB` - Use `quoteString` instead
		- `dropDatabase` - Use `dropSelectedDatabase`
		- `createDatabase` - Use `selectDatabase` with the second parameter set to true instead
		- `allDatabaseNames` - Use `databaseList` instead
		- `currentDatabase` - Use `getSelectedDatabase` instead
		- `addslashes` - Use `escapeString` instead
 * LogErrorEmailFormatter now better displays SQL queries in errors by respecting line breaks
 * Installer has been majorly upgraded to handle the new database configuration options
   and additional PDO functionality.
 * Created SS_DatabaseException to emit database errors. Query information such as SQL
   and any relevant parameters may be used by error handling user code that catches
   this exception.
 * The SQLConditionGroup interface has been created to represent dynamically 
   evaluated SQL conditions. This may be used to wrap a class that generates
   a custom SQL clause(s) to be evaluated at the time of execution.
 * DataObject constants CHANGE_NONE, CHANGE_STRICT, and CHANGE_VALUE have been created
   to provide more verbosity to field modification detection. This replaces the use of
   various magic numbers with the same meaning.
 * create_table_options now uses constants as API specific filters rather than strings.
   This is in order to promote better referencing of elements across the codebase.
   See `FulltextSearchable->enable` for example.
